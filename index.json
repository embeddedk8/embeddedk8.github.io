[{"categories":["Arduino Internals"],"content":"Compiling with Arduino CLI","date":"2025-10-01","objectID":"/arduino-cli-compilation/","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"In the previous post we took a closer look on build process in the Arduino IDE. It turned out that a lot of things go on behind the scenes - the classic steps of preprocessing, compiling, and linking, along with a few Arduino-specific addons to the process. Now, let’s take a more advanced approach and build the same project without the Arduino IDE - using the Arduino CLI. Compiling Arduino sketch via Arduino CLI Ok, but why would we want to use CLI at the first place, when the Arduino IDE already provides such a simple way to build and upload sketches? Maybe, because of… Advanced configuration options Some build or configuration options aren’t exposed in the IDE. With the CLI, you can fully control compiler flags, board settings, library versions from command line. Automation and integration The CLI makes it easy to compile, verify, and upload sketches automatically. It can run on systems without a graphical interface, such as Docker containers. Reproducibility Makes sure that your colleague compiles with exactly the same setup as you. IDE independence Use your favourite IDE for code development! I am sure it was enough to convince you to give it a try, so let’s start! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Installing Arduino CLI In September 2024, Arduino released a major update to Arduino CLI. As of October 2025, the latest version is Arduino CLI 1.3.1, which I’ll be using here. Please refer to official installation guide to install Arduino CLI. Note On Linux, I installed the Arduino CLI in just a few seconds with just one command: curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Setup your board core After Arduino CLI is installed, you need to install needed boards definitions [1]. First, let’s update the board index: arduino-cli core update-index Then you need to install the core relevant for your board. Right now, we don’t know what is the core id that we need. So let’s peek what we can choose: ~/Arduino/MyBlink$ arduino-cli core search Downloading index: package_index.tar.bz2 downloaded ID Version Name arduino:avr 1.8.6 Arduino AVR Boards arduino:esp32 2.0.18-arduino.5 Arduino ESP32 Boards arduino:megaavr 1.8.8 Arduino megaAVR Boards arduino:nrf52 1.0.2 Arduino nRF52 Boards arduino:renesas_uno 1.5.1 Arduino UNO R4 Boards arduino:sam 1.6.12 Arduino SAM Boards (32-bits ARM Cortex-M3) ... Ok, so it’s clear now, that for Arduino UNO R4 WiFi that I have I need to use arduino:renesas_uno ID. So let’s install needed boards definitions: arduino-cli core install arduino:renesas_uno The preparations are done! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:1:1","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Creating a new sketch You can create new sketch with $ arduino-cli sketch new MyFirstSketch Sketch created in: /XXX/MyFirstSketch But I want to reuse MyBlink sketch, that I was working on as in previous post. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Compile a sketch To compile a sketch, use arduino-cli compile command followed by: --fqbn \u003cid\u003e - your board id, \u003csketch root dir\u003e - the path to root directory of the sketch to compile. So to compile MyBlink that was previously compiled with the IDE, I will use: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi /home/kate/Arduino/MyBlink Again, like we already saw in IDE, the default output is very concise. arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi /home/kate/Arduino/MyBlink Sketch uses 51880 bytes (19%) of program storage space. Maximum is 262144 bytes. Global variables use 6740 bytes (20%) of dynamic memory, leaving 26028 bytes for local variables. Maximum is 32768 bytes. We can enable verbose output here too. arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Uploading a sketch Before we jump to upload command, we must now to which port is the board connected. How can we check it? Good news - no need to observe ls /dev/tty* with board plugged and unplugged. There is a command for it too: arduino-cli board list Port Protocol Type Board Name FQBN Core /dev/ttyACM0 serial Serial Port (USB) Arduino UNO R4 WiFi arduino:renesas_uno:unor4wifi arduino:renesas_uno Knowing the port, board ID and sketch directory, the upload command looks like this: arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Customizing command The compile command can be extended with additional stuff, like extra compiler flags: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink --build-property compiler.c.extra_flags=\"-Wall -O2\" Full documentation of Arduino CLI commands is here: https://arduino.github.io/arduino-cli/1.3/commands ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Permanent CLI settings If you want to set permanent settings to your CLI, create a config file if you haven’t: arduino-cli config init Config file written to: /home/kate/.arduino15/arduino-cli.yaml Take a look, if you’ve just created it, it should be empty now: arduino-cli config dump board_manager: additional_urls: [] Settings added globally to this file will affect all builds done with Arduino CLI. You can also set some options per-board. Info This blog post is still work in progress… It will be updated soon! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"More reading https://docs.arduino.cc/arduino-cli/ https://arduino.github.io/arduino-cli/1.3/getting-started/ https://evan.widloski.com/notes/arduino_cli.html https://dumblebots.com/blog/arduino-cli-getting-started ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Step by step guide to how the Arduino IDE builds the code — preprocessing, compiling, and linking explained simply","date":"2025-09-13","objectID":"/arduino-ide-build-process/","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"As an embedded developer, you probably can’t help wondering what actually happens when Arduino IDE builds the sketch. What’s being compiled, where the files go, and how the toolchain turns the code into instructions able to run on the board? You hit the spot! We’re about to take a closer look at the Arduino build process. While building an Arduino sketch in the IDE seems as simple as clicking one button, under the hood it performs several important steps — some common to nearly every embedded development environment, and others unique to Arduino. Understanding this process is a great way to move beyond the beginner stage and start thinking like an embedded developer. Understanding Arduino IDE build process Assumed knowledge I assume you already know how to compile and flash an Arduino board with the Arduino IDE, but haven’t yet dived into the internals of the compilation and flashing process. My setup Arduino UNO R4 WiFi board Arduino IDE 2.3.6 Linux Mint If you’re using a different board, IDE version, or operating system — don’t worry! You can still follow along. Some details may just look a little different on your setup. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"What you will learn? After reading this article, you will: understand the standard build flow in embedded software development, learn about the additional steps performed during the Arduino build process, know where to find the build files and caches. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Let’s get started! Let’s build a sketch together and go step through the build process. We’ll pretend we know nothing and analyze the build output to infer what the Arduino IDE actually did. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Build an example sketch Open the Arduino IDE and select the correct board from Select Board menu. In my case it’s Arduino UNO R4 WiFi. Load the Blink example and save the sketch in your sketchbook. Then, to trigger the build, click Verify/Compile and observe the Output window. In my IDE, only a very short message has appeared in Output window. It looks that the sketch has been built successfully and is ready to upload to the board. The message contains just two lines because I haven’t changed the Arduino IDE’s default settings yet — by default, most of the build output is hidden. Arduino IDE - default build output ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Enable verbose output To understand the build process better we need to enable the verbose output in IDE. To do so, go to File-\u003e Preferences and check Show verbose output setting for both compiling and upload. When you compile again, the output will be complete. Let’s break it down to atoms! Arduino IDE - verbose build output ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Board and package identification The first lines in Output are identifying the board. When building a sketch, the Arduino environment needs to know exactly which board you are using — and it knows it because you have selected the right board from Select Board menu. Thanks to this, the compiled code will match the board’s architecture, hardware, pin mapping etc. This board identity is called FQBN (Fully Qualified Board Name) and looks as follows: FQBN: arduino:renesas_uno:unor4wifi FQBN is unique for each board. It consists of three segments: Vendor: arduino (it’s official Arduino package) Architecture: renesas_uno (Renesas-based boards family) Board: unor4wifi (exact model: Arduino Uno R4 WiFi). If you choose wrong board, the code may compile but fail at runtime, or compilation may fail. Tip Error Compilation error: Missing FQBN (Fully Qualified Board Name) means you have not selected any board from menu. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino specific directories The compilation artifacts and packages used by the Arduino environment are stored in several hidden directories. You can see their paths in the build log — let’s take a closer look. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino15 directory Arduino15 contains user preferences, downloaded board packages (cores, toolchains, board definitions) and libraries that Arduino automatically installs. The exact location depends on your operating system. You will see it under the FQBN log: Using board 'unor4wifi' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 Using core 'arduino' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 Take a look on boards.txt file for your platform, located in the directory listed above. This file lists all supported boards. Each board has its own section with key-value pairs that define how to compile, upload, and debug for that target. Here’s the entry for the Arduino UNO R4 WiFi: ############################################################## unor4wifi.name=Arduino UNO R4 WiFi unor4wifi.build.core=arduino unor4wifi.build.crossprefix=arm-none-eabi- unor4wifi.build.compiler_path={runtime.tools.arm-none-eabi-gcc-7-2017q4.path}/bin/ unor4wifi.build.variant=UNOWIFIR4 unor4wifi.build.mcu=cortex-m4 unor4wifi.build.architecture=cortex-m4 unor4wifi.build.fpu=-mfpu=fpv4-sp-d16 unor4wifi.build.float-abi=-mfloat-abi=hard unor4wifi.upload.tool=bossac ... Thanks to those settings, once you select your board from the Select Board menu, the correct toolchain, compiler flags (such as MCU type and clock speed) and upload tool are selected automatically. Do you want to move Arduino15 folder? In some cases, you may want to move the Arduino15 folder — for example, to free up space on your primary drive. To do this: Copy the Arduino15 directory to your desired location. Open the file ~/.arduinoIDE/arduino-cli.yaml and update the directories:data path, for example: board_manager: additional_urls: [] directories: data: /home/kate/new-location-arduino15 Restart the Arduino IDE. It will now use the new Arduino15 location. Verify the build output to ensure everything is working correctly. Once you’ve confirmed everything works correctly, you can safely delete the old folder. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino core Inside Arduino15 directory there is a folder called Arduino Core. It contains the essential components of your Arduino program and is specific to the hardware platform you are using. You can find it in the cores subdirectory of your board package, for example: .arduino15/packages/arduino/hardware/renesas_uno/1.4.1/cores/ The Arduino Core contains, among others: main.cpp file, defining the code that is executed even before your setup() is called, and calling your loop() in a loop, Arduino.h header — the main include for all sketches, implementations of interrupts, UART communication, timing functions like delay etc. Open the main.cpp and browse the logic that Arduino is adding around the code you implemented in the sketch. Info The Arduino Core implements the Arduino API for a specific architecture or chip family. Each family, or board platform, has its own core, tailored to the hardware and peripherals. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Build directory When you compile a sketch, the Arduino IDE doesn’t build it directly in your project folder. Instead, it creates a build directory — a per-sketch cache — in a hidden folder to store all intermediate files. This approach lets the IDE generate builds for different boards or variants without cluttering your sketch folder. You can find the path to this build directory in the build log. My sketch was built here: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/`. If you open this folder, you’ll see the build artifacts, including: object files (.o), preprocessed sources (.cpp), final binaries (.bin, .hex, .elf). Exporting Compiled Binary If you want to have the compiled binaries in your sketch folder, click Sketch → Export Compiled Binary option from Arduino IDE menu. This will build your sketch and place a copy of the .hex, .bin, .elf and .map inside the sketch sources folder so it’s easy to find later. Now, let’s move to the preprocessing stage. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Preprocessing The first phase of every C/C++ program build is preprocessing. In Arduino, preprocessing includes some specific steps. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Detecting libraries used Before any actual compilation happens, the Arduino IDE scans your code to figure out which additional libraries your sketch needs. In the build log, you’ll see something like this (shortened for readability): Detecting libraries used... /home/kate/.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/arm-none-eabi-g++ (...) -E \\ /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /dev/null Here, the compiler is invoked with the -E flag, which tells it to stop after the preprocessing stage and not produce any compiled output. It will only expand all #include directives and check which libraries are required for your sketch. Based on this, the IDE knows which libraries should be compiled and which include directories need to be added to the build process. For a simple sketch like Blink, this stage isn’t very exciting: it doesn’t pull in any additional libraries. That’s why the build output doesn’t show anything under Detecting libraries used…. Open other example sketches, such as those from WiFiS3 or EEPROM, and you’ll see how more complex projects trigger detection of multiple libraries. Why such preprocessing is needed? Arduino IDE compiles only the libraries that your sketch needs. In other development environments, this step is usually the developer’s responsibility: you must explicitly tell the compiler which libraries or dependencies to include in the build. Arduino automates this process, scanning your code and selecting what’s needed. Tip Notice the toolchain path: .arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/. Besides the compiler itself, toolchain contains other useful tools like objdump. We may use it later! ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:5:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Automatic function prototypes generation The next stage in the build process is automatic function prototype generation. In C or C++, each function must be either defined or declared before it’s called. In Arduino, you don’t need to worry about that - you can write whatever functions in any order, without adding their prototypes. How does it work? Arduino generates these prototypes for you! Here’s what the build log shows: Generating function prototypes... arm-none-eabi-g++ (...) -E /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /tmp/1121713208/sketch_merged.cpp ctags (...) /tmp/1121713208/sketch_merged.cpp Again, the compiler is invoked with the -E flag, meaning only the preprocessor runs. Behind the scenes, the Arduino IDE performs these steps for you: Concatenate .ino files All .ino files in the sketch folder are concatenated into a single file (MyBlink.ino.cpp). Preprocess it The new MyBlink.ino.cpp is input for the preprocessor: #includes are expanded and macros replaces. The expanded file is stored as /tmp/1121713208/sketch_merged.cpp. Scan functions Tool ctags is running over expanded sketch_merged.cpp, to extract function symbols. Generate prototypes Based on the ctags result, the IDE inserts forward declarations (prototypes) for you. This way, you don’t need to worry about undeclared functions, functions order, etc. Store prototypes into .ino.cpp The resulting version is stored into MyBlink.ino.cpp. This is what the compiler will actually use later on. Your simple sketch (MyBlink.ino): void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } gets transformed into (MyBlink.ino.cpp): #include \u003cArduino.h\u003e #line 1 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup(); #line 32 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void loop(); #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } To summarize differences: #include \u003cArduino.h\u003e in preprocessed file there is \u003cArduino.h\u003e header added, #line macros These keep compiler error messages pointing to the right lines in your .ino file. Without them, errors would show up with the line numbers of the generated .cpp, which would be super confusing. function prototypes are added. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:5:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compilation ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Sketch compilation Here’s where your code finally turns into machine instructions. Compiling sketch... arm-none-eabi-g++ (...) -c sketch/MyBlink.ino.cpp -o sketch/MyBlink.ino.cpp.o Now we reached the sketch compilation. Compiler is ivoked with -c flag, which means compile only (generate object code .o, don’t link). Input: MyBlink.ino.cpp - the auto-generated sketch with prototypes, includes, and line directives. Output: MyBlink.ino.cpp.o - machine-code object file, ready to be linked later. I shortened the compilation command, so it’s not in the snippet above, but in IDE we can observe a lots of compilation flags that were used. Some highlights: -Os → optimize for size. -g3 → include debug info at max level. -fno-rtti, -fno-exceptions → strip C++ runtime features to save space. -nostdlib → don’t link against standard system libraries. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 → target an ARM Cortex-M4 with hardware floating point. -I and @.../includes.txt → add search paths for Arduino core and variant headers. Many -D... → defines for board, CPU frequency, Arduino version, etc. Note Most advanced IDEs let you change compiler settings like optimization level, debug info, or extra flags right from a project menu. Arduino IDE is so simple that it doesn’t offer this option: you don’t get a button or menu for that. If you want to change some settings, you’ve got two ways: Edit build recipes: you can change files like platform.txt or boards.local.txt to change or add your own compilation flags. Use Arduino CLI: the command-line tool gives you more flexibility and can build your sketch with whatever options you like. At this point, your sketch has been turned into machine code, stored in MyBlink.ino.cpp.o. This file contains your setup() and loop() code, ready to be linked with the Arduino core and libraries in the next step. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling libraries Compiling libraries... For the Blink sketch this step is empty. In the previous phase (Detecting libraries used) no additional libraries were found. Blink only relies on core Arduino functions such as pinMode, digitalWrite, and delay, which are part of the board core, not separate libraries. In more advanced sketches the output looks different. For example, in WiFiS3/ConnectWithWPA the WiFiS3 library is detected and its source files are compiled here. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling core Compiling core... Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/pin_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/main.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/common_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/variant.cpp.o Using precompiled core: /home/kate/.cache/arduino/cores/arduino_renesas_uno_unor4wifi_4e1bf6711f2b98688d9a4a386931d6dc/core.a The core is the foundation of every Arduino program. It provides the low-level code relevant to the specific board you selected, like startup code, pin mappings, and implementations of important functions. Instead of recompiling the same core files every time you build, the Arduino IDE uses precompiled objects from a cache. It speeds up the compilation. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Linking everything together Once all the individual files are compiled, the Arduino build system needs to link them into a single program. I shortened the link command to present only the most important stuff: arm-none-eabi-g++ \\ -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16 \\ -o MyBlink.ino.elf \\ MyBlink.ino.cpp.o common_data.c.o main.c.o pin_data.c.o variant.cpp.o \\ libfsp.a core.a \\ -lstdc++ -lsupc++ -lm -lc -lgcc -lnosys After this step, the final binary will be MyBlink.ino.elf. Please note which libraries are linked into the build: libfsp.a → the Renesas Flexible Software Package, providing hardware drivers and low-level functions for peripherals. core.a → the Arduino core for this board. Libraries above are board support libraries. These are part of the Arduino board package (for the Uno R4 in this case). They are not optional user libraries, so they don’t appear in the detection phase. Toolchain standard libraries: -lstdc++ → the C++ standard library, -lsupc++ → low-level C++ runtime support, -lm → the math library, -lc → the standard C library, -lgcc → helper routines from GCC itself, -lnosys → stubs for system calls. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Finalizing build ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Creating binary and hex files After the ELF file (MyBlink.ino.elf) is created, the build system uses objcopy to generate hex and bin formats: arm-none-eabi-objcopy -O binary -j .text -j .data MyBlink.ino.elf MyBlink.ino.bin arm-none-eabi-objcopy -O ihex -j .text -j .data MyBlink.ino.elf MyBlink.ino.hex Both formats contain the same program, just encoded differently for different flashing tools. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Measuring the program size Finally, the build system reports memory usage with arm-none-eabi-size: arm-none-eabi-size -A MyBlink.ino.elf ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Cleaning the build Unfortunately, Arduino IDE does not offer the Clean build or Force rebuild option ([1], [2], [3]). The workaround for it is to manually delete the cached build directories we mentioned earlier. A much better alternative is to use Arduino CLI, which is more flexible and gives you full control over compilation and rebuilding. Tip The Arduino UNO R4 WiFi is based on an ARM architecture. Be aware that some other Arduino boards (like the UNO R3 or Mega 2560) use AVR architecture instead. This means the compilation process and generated machine code will differ between these boards. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"More reading Build Sketch Process from docs.arduino.cc Find sketches, libraries, board cores and other files on your computer from support.arduino.cc ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Digging deeper ARM Reverse Engineering Notes: Compilation Open issues in arduino-cli related to build process De-Mystifying Libraries - How Arduino IDE Finds and Uses Your Files - OhioIoT ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":null,"content":"About embeddedk8","date":"2025-09-14","objectID":"/about/","tags":null,"title":"About embeddedk8","uri":"/about/"}]