[{"categories":["Arduino Internals"],"content":"Build and upload sketches using Arduino CLI. Benefits, how to setup, upload sketches, configure, automate and create CI/CD pipeline","date":"2025-10-01","objectID":"/arduino-cli-compilation/","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Do you know that you don‚Äôt actually need the Arduino IDE to build and upload sketches? Arduino projects can be compiled and uploaded straight from the command line using the Arduino Command Line Interface (CLI). This process is identical to what happens when you build and upload from the IDE, because Arduino IDE 2.0 and later use arduino-cli under the hood. By working directly with the CLI, you remove the IDE as a middle layer and gain more possibilities and control over your builds. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Reasons to use Arduino CLI If you were comfortable using IDE, you may not immediately see why would you use Arduino CLI instead. In Arduino Exchange forum you can find suggestion that ‚ÄúIf you have to ask what the benefits are then the benefits most likely do not apply to or interest you.‚Äù. That‚Äôs not entirely fair, though ‚Äî it overlooks the fact that people want to learn new things. Arduino IDE is great for getting started, but you can do much more if you switch to Arduino CLI: Use advanced configuration options Some build or configuration options aren‚Äôt exposed in the Arduino IDE. It‚Äôs possible to configure them with configuration files, but this way is more complicated and harder to maintain ‚Äî global configuration would affect all projects, per-board or per-sketch configuration would be time-consuming. With the CLI, you can fully control compiler flags, custom defines and board settings from command line, for each project separately. Automate your builds and create CI/CD pipelines Using the CLI, you can easily implement the scripts for tasks like building, uploading, deploying and testing the project. These scripts can run on lightweight systems without graphical interface, such as Docker containers. This makes possible to integrate Arduino project into the CI/CD pipeline for automated builds and testing. Ensure reproducibility for your builds When working in a team, using the Arduino CLI ensures that everyone builds the project with exactly the same setup and dependencies. This helps eliminate the classic ‚Äúit works on my machine‚Äù problem and makes builds consistent across different environments. Use your favourite IDE, not necessarily Arduino IDE You don‚Äôt have to use Arduino IDE to develop your projects. With the CLI, you can use your favorite code editor ‚Äî whether it‚Äôs for better IntelliSense, built-in integrations like GitHub Copilot, or simply because you‚Äôre more comfortable with it. Have full control over project dependencies In Arduino IDE, only one version of a library can be installed at the same time. This becomes a real problem when you work on multiple projects that require different versions of the same library. This issue is solved when using CLI ‚Äî you can specify library versions directly from the command line, ensuring each one uses the correct dependencies. Hopefully, that was enough to convince you to give the Arduino CLI a try! Alright, it‚Äôs time to get our hands dirty. We‚Äôll install the Arduino CLI, set it up, and then build the project from the command line. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Arduino CLI setup If you already have arduino-cli installed and working, you can jump to Basic usage chapter. In September 2024, Arduino released a major update to Arduino CLI. As of October 2025, the latest version is Arduino CLI 1.3.1, which I‚Äôll be using here. Please refer to official installation guide to install Arduino CLI on your system. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Installing Arduino CLI Note The quickest way to install the Arduino CLI on Linux is with a single command (check for updates here!): curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh Other way, or if you have issues with above command, you can download a prebuilt binary from the Download section, and manually add it to your PATH. Warning ‚ö†Ô∏è Avoid installing arduino-cli with snap. The Snap package is not officially supported. It often causes permission and path issues (for example, this one ‚Äî it happened to me when I used snap on Ubuntu 24.04). If you‚Äôve already installed it with snap and it‚Äôs not working, remove it and reinstall using one of the methods above. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:1","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Check installation After installing, type arduino-cli in your terminal, to confirm that the tool was installed successfully. $ arduino-cli Arduino Command Line Interface (arduino-cli). Usage: arduino-cli [command] ... Additionally, check if boards discovery works well: $ arduino-cli board list Port Protocol Type Board Name FQBN Core /dev/ttyS4 serial Serial Port Unknown All good on my side! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:2","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Setup your board core After Arduino CLI is installed, you need to install needed boards definitions [1]. First, let‚Äôs update the board index: arduino-cli core update-index Then you need to install the core relevant for your board. Right now, we don‚Äôt know which core id we need, so let‚Äôs see what we can choose: $ arduino-cli core search Downloading index: package_index.tar.bz2 downloaded ID Version Name arduino:avr 1.8.6 Arduino AVR Boards arduino:esp32 2.0.18-arduino.5 Arduino ESP32 Boards arduino:megaavr 1.8.8 Arduino megaAVR Boards arduino:nrf52 1.0.2 Arduino nRF52 Boards arduino:renesas_uno 1.5.1 Arduino UNO R4 Boards arduino:sam 1.6.12 Arduino SAM Boards (32-bits ARM Cortex-M3) ... I have Arduino Uno R4 WiFi, so I need to use arduino:renesas_uno id. I will install it with following command: arduino-cli core install arduino:renesas_uno The preparations are done! It was easy, wasn‚Äôt it? ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:3","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Basic usage To start using Arduino CLI, you actually just need to use three basic commands: create new sketch, build a sketch and upload the binary to the board. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Creating a new sketch You can create new sketch with $ cd Arduino $ arduino-cli sketch new MyFirstSketch Sketch created in: /home/kate/Arduino/MyFirstSketch By default, the sketches are created inside current working directory. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:1","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Compile a sketch To compile a sketch, use arduino-cli compile command followed by: --fqbn \u003cid\u003e ‚Äî your board id (mandatory), \u003csketch root dir\u003e ‚Äî the path to root directory of the sketch to compile (mandatory, unless you‚Äôre inside the sketches root dir), --verbose ‚Äî verbose flag to print all build logs to console (if you want it). I can compile MyBlink sketch with following command: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:2","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Uploading a sketch Before we jump to upload command, we must now to which port is the board connected. How can we check it? Good news ‚Äî no need to observe ls /dev/tty* and plug and unplug the board. There is a command for it too: $ arduino-cli board list Port Protocol Type Board Name FQBN Core /dev/ttyACM0 serial Serial Port (USB) Arduino UNO R4 WiFi arduino:renesas_uno:unor4wifi arduino:renesas_uno Knowing the port, board id and sketch directory, the upload command looks like this: arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink So it was basically all needed to replace the usage of Arduino IDE Verify/Compile and Upload actions. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:3","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Serial monitor If your application sends data using Serial.write() or Serial.print(), you can view it using the monitor command in the Arduino CLI. Make sure the baud rate in your monitor command matches the one you set in your sketch. For example, if your code includes: Serial.begin(115200); then you should start the monitor with the same baud rate: arduino-cli monitor -p /dev/ttyACM0 --config 115200 Using serial prints is one of the simplest ways to debug your Arduino applications. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:4","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Basic flow In summary, the basic arduino-cli workflow is as follows: Basic flow of using arduino-cli ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:5","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Advanced usage ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Specify build folder By default, Arduino CLI places build artifacts in a temporary, system-specific folder ‚Äî which can make it hard to inspect. To keep your build outputs organized and easy to analyze, specify a custom build folder using the --build-path flag: $ arduino-cli compile \\ /home/kate/Arduino/MyBlink \\ --fqbn arduino:renesas_uno:unor4wifi \\ --verbose \\ --build-path /home/kate/Arduino/MyBlink/build Now, all generated files are stored in the build/ directory within your project: ~/Arduino/MyBlink/build$ tree -L 1 . ‚îú‚îÄ‚îÄ build.options.json ‚îú‚îÄ‚îÄ compile_commands.json ‚îú‚îÄ‚îÄ core ‚îú‚îÄ‚îÄ includes.cache ‚îú‚îÄ‚îÄ libraries ‚îú‚îÄ‚îÄ libraries.cache ‚îú‚îÄ‚îÄ MyBlink.ino.bin ‚îú‚îÄ‚îÄ MyBlink.ino.elf ‚îú‚îÄ‚îÄ MyBlink.ino.hex ‚îú‚îÄ‚îÄ MyBlink.ino.map ‚îî‚îÄ‚îÄ sketch 4 directories, 8 files This layout makes it much easier to explore build files, inspect compilation issues, or integrate the build with external tools (like static analyzers). ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:1","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Optimize for debug The --optimize-for-debug flag adjusts compilation settings to make debugging easier. You can review or modify its behavior in the platform.txt file. When --optimize-for-debug is enabled, the debug version of the optimization flags is applied; otherwise, the release version is used by default. You can edit these flags in platform.txt to customize how each mode behaves. compiler.optimization_flags.release=-Os compiler.optimization_flags.debug=-Og -g It‚Äôs good idea to store build files for debug and release version in separate build folders, using already discussed --build-path: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi \\ --verbose /home/kate/Arduino/MyBlink \\ --build-path /home/kate/Arduino/MyBlink/build/debug \\ --optimize-for-debug arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi \\ --verbose /home/kate/Arduino/MyBlink \\ --build-path /home/kate/Arduino/MyBlink/build/release This way, you have debug optimized version in MyBlink/build/debug, and release version in MyBlink/build/release. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:2","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Custom defines Let‚Äôs go back to our old MyBlink sketch. Currently, the LED blinks with a hardcoded delay of 1000 ms. We can make this configurable at compile time by introducing a custom define called BLINK_FREQUENCY. First, update the MyBlink sketch to use the new frequency. If no value is provided from the command line, it will default to 1000 ms; otherwise, it will use the value you specify. #ifndef BLINK_FREQUENCY #define BLINK_FREQUENCY 1000 #endif void loop() { Serial.write(\"Blinking\"); digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(BLINK_FREQUENCY); // wait for a BLINK_FREQUENCY ms digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(BLINK_FREQUENCY); // wait for a BLINK_FREQUENCY ms } By adjusting the compile command, you can easily change how fast the LED blinks. For example, build.extra_flags=\"-DBLINK_FREQUENCY=100\" part below sets the blink frequency to 100 ms: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose --build-property build.extra_flags=\"-DBLINK_FREQUENCY=100\" ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:3","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Customizing command The platform.txt file defines the build recipes that the Arduino ecosystem uses to compile, link, and package a sketch. These recipes use variables that we can override when we need custom behavior. Some of these editable variables are: # this can be overriden in boards.txt build.extra_flags= build.extra_ldflags= # These can be overridden in platform.local.txt compiler.c.extra_flags= compiler.c.elf.extra_flags= compiler.S.extra_flags= compiler.cpp.extra_flags= compiler.ar.extra_flags= compiler.objcopy.eep.extra_flags= compiler.elf2hex.extra_flags= These comments encourage us to override the variables in platform.local.txt or boards.txt, but when using the CLI there is an easier and cleaner approach: instead of modifying any files, we can override them directly from the command line using --build-property. This keeps your setup clean and allows you to change the settings for a specific build only. For example: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi \\ --verbose \\ --build-property build.extra_flags=\"-DBLINK_FREQUENCY=100\" \\ --build-property compiler.cpp.extra_flags=\"-pedantic -Werror\" ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:4","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Writing a simple Makefile As our build command becomes longer, it becomes harder to remember and type correctly each time. To make it easier, we can wrap these commands inside a script that lives in the root directory of the project. This could be a bash script, but an even better option is a Makefile. Creating a Makefile for our Arduino project is very simple. At the top of the Makefile, we define a few variables such as FQBN and PORT. These values are hardcoded for simplicity, feel free to change them to match your board and serial port. # FQBN for your board (change if needed) FQBN := arduino:renesas_uno:unor4wifi # Serial port (change if needed) PORT := /dev/ttyACM0 # Build dirs BUILD_DEBUG := build/debug BUILD_RELEASE := build/release # Arduino CLI executable ARDUINO_CLI := arduino-cli # Default build release all: release debug: $(ARDUINO_CLI) compile \\ --fqbn $(FQBN) \\ --build-path $(BUILD_DEBUG) \\ --optimize-for-debug \\ --verbose release: $(ARDUINO_CLI) compile \\ --fqbn $(FQBN) \\ --build-path $(BUILD_RELEASE) \\ --verbose upload-debug: debug $(ARDUINO_CLI) upload \\ -p $(PORT) \\ --fqbn $(FQBN) \\ --input-dir $(BUILD_DEBUG) upload-release: release $(ARDUINO_CLI) upload \\ -p $(PORT) \\ --fqbn $(FQBN) \\ --input-dir $(BUILD_RELEASE) monitor: $(ARDUINO_CLI) monitor -p $(PORT) clean: rm -rf build .PHONY: all debug release upload-debug upload-release clean monitor Once the Makefile is in the project root, using it becomes extremely easy: # Build and upload debug make debug make upload-debug # Build and upload release make release make upload-release # Open serial monitor make monitor # Clean builds make clean ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Summary Using the Arduino CLI gives you full control over the build process, from compiling to uploading sketches, without relying on the Arduino IDE. It‚Äôs perfect for automation, reproducibility, and integrating Arduino projects into advanced workflows or CI/CD pipelines. Benefits from using arduino-cli ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"More about Arduino CLI üìö Official documentation of Arduino CLI üìö Detailed article showing how to install and integrate CLI with VSCode üé¨ Arduino CLI - What and Why? | Breaking Out of Arduino IDE | Part 2 | Magpie Embedded on YouTube üé¨ Arduino CLI and the art of command line | Sayanee Basu on YouTube üõ†Ô∏è Arduino CLI Manager | interactive shell wrapper for Arduino CLI ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Step by step guide to how the Arduino builds the code ‚Äî preprocessing, compiling, and linking explained simply","date":"2025-09-13","objectID":"/arduino-ide-build-process/","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino is one of the most popular ways to start learning embedded systems. At the same time, you can find plenty of debates online about whether Arduino is a good choice for that (like ‚ÄúIs there anything wrong with Arduino?‚Äù, ‚ÄúWhy engineers hate Arduino?‚Äù [1], [2] ). While the list of arguments from Arduino ‚Äúopponents‚Äù is quite long ‚Äî and some of their points are completely reasonable ‚Äî I want to prove that you can learn just as much with Arduino as with any other embedded platform, as long as you avoid blindly relying on the Arduino API and stay curious to explore what‚Äôs happening under the hood. That‚Äôs why I am creating the Arduino Internals series. As a starting point, let‚Äôs take a closer look at what happens when you build a sketch in the Arduino IDE. Assumed knowledge I assume you already know how to compile and flash an Arduino board with the Arduino IDE, but haven‚Äôt yet dived into the internals of the compilation and flashing process. My setup Arduino UNO R4 WiFi board Arduino IDE 2.3.6 Ubuntu 24.04 If you‚Äôre using a different board, IDE version, or operating system ‚Äî don‚Äôt worry! You can still follow along. Some details may just look a little different on your setup. Understanding Arduino build process Building an Arduino sketch in the IDE seems as simple as clicking one button, but under the hood it performs several important steps ‚Äî some common to nearly every embedded development environment, and others unique to Arduino. This simplicity is great for beginners, but if you want to take embedded systems seriously, it‚Äôs worth understanding what really happens behind the scenes. Once you move beyond Arduino‚Äôs friendly abstraction layer, you‚Äôll need to know how the build process works ‚Äî because without it, things may not behave as you expect. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"What you will learn? After reading this article, you will: understand the standard build flow in embedded software development, learn about the additional steps performed during the Arduino build process, know where to find the build files, caches, and linked libraries, discover what language Arduino sketches are actually written in. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Let‚Äôs get started! Let‚Äôs build a sketch together and go step through the build process. We‚Äôll pretend we know nothing and analyze the build output to see what the Arduino IDE actually did. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Opening an example sketch Open the Arduino IDE and select the correct board from Select Board menu. In my case it‚Äôs Arduino UNO R4 WiFi. Load the Blink example and save the sketch in your sketchbook. This example consists of a single file: Blink.ino. Files with the .ino extension contain code written in the Arduino language [1]. You may notice there is no main function in this code, yet it still compiles. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"What exactly is Arduino language? According to the official documentation the Arduino language consists of: set of functions like digitalRead, digitalWrite etc, predefined constants such as HIGH and LOW, basic data types like array, bool, int, special sketch functions such as loop, setup‚Ä¶ And so on. You can just read the full list on the official page. There‚Äôs also a brief note mentioning that Arduino is based on C++. Well ‚Äî we‚Äôll see at the end of our investigation, if Arduino language is actually a language‚Ä¶ or just a C++ in a disguise. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Triggering the build We are ready to build this sketch. Click Verify/Compile and observe the Output window. Arduino IDE - default build output It looks like the sketch has been built successfully and is ready to upload to the board. You only see two lines of output because the Arduino IDE hides most of the build details by default. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Enabling verbose output To understand the build process better we need to enable the verbose output in IDE. To do so, go to File ‚Üí Preferences and check Show verbose output setting for both compiling and upload. When you compile again, the output will be complete. Let‚Äôs read it line by line. Arduino IDE - verbose build output ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:4","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Board and package identification In embedded software development, the compilation process is always target-dependent. Each hardware architecture ‚Äî such as ARM or AVR ‚Äî requires its own dedicated cross-compilation toolchain. In addition, the appropriate version of the hardware libraries must be selected and linked. Therefore, the target board must be identified before the build begins. Arduino handles this step automatically. It looks at the board you‚Äôve chosen in the Select Board menu and configures the build accordingly. This ensures that the compiled code will match the board‚Äôs architecture, hardware, pin mapping etc. This board identity is called FQBN (Fully Qualified Board Name) and looks as follows: FQBN: arduino:renesas_uno:unor4wifi FQBN is unique for each board. It consists of three segments: Vendor: arduino (it‚Äôs official Arduino package) Architecture: renesas_uno (Renesas-based boards family) Board: unor4wifi (exact model: Arduino Uno R4 WiFi). If you choose wrong board, the code may compile but fail at runtime, or compilation may fail. Tip Error Compilation error: Missing FQBN (Fully Qualified Board Name) means you have not selected any board from menu. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino specific directories In a typical embedded development environment, the build process produces various artifacts (object files, binaries, maps, etc.), which are stored in a user-defined or default build directory. Knowing where these artifacts are located allows developers to: see which source files are compiled, inspect intermediate and output files (e.g., .o or .elf) to diagnose build or linking issues, analyze additional information from .map file. In most embedded IDEs, the user also knows and can control where all linked libraries come from. In Arduino, location of build artifacts and used libraries is not immediately obvious, since these files are placed in several hidden directories. However, their locations can be found in the build log. Let‚Äôs take a quick look at these directories. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino15 directory Arduino15 contains, among others: installed board packages (cores, board definitions, hardware specific libraries), global libraries that Arduino automatically installs, tools needed for development with Arduino (like toolchains and flashing tools), user preferences, customized settings, etc. The exact location depends on your operating system [1]. Board packages The build log shows the directory where the target board‚Äôs related files are located, for example: Using board 'unor4wifi' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 Using core 'arduino' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 Inside this directory, two files deserve special attention: boards.txt and platform.txt. boards.txt The boards.txt file lists all boards supported by this platform. Each board has its own section with key-value pairs that define how to compile, upload, and debug for that target. Here‚Äôs the entry for the Arduino UNO R4 WiFi: ############################################################## unor4wifi.name=Arduino UNO R4 WiFi unor4wifi.build.core=arduino unor4wifi.build.crossprefix=arm-none-eabi- unor4wifi.build.compiler_path={runtime.tools.arm-none-eabi-gcc-7-2017q4.path}/bin/ unor4wifi.build.variant=UNOWIFIR4 unor4wifi.build.mcu=cortex-m4 unor4wifi.build.architecture=cortex-m4 unor4wifi.build.fpu=-mfpu=fpv4-sp-d16 unor4wifi.build.float-abi=-mfloat-abi=hard unor4wifi.upload.tool=bossac ... These settings ensure that once you select your board from the Select Board menu, the correct toolchain, compiler flags (such as MCU type and clock speed) and upload tool are selected automatically. Advanced users may feel need to modify the boards.txt contents, to i.e. add new board or customize some build options. Just remember that such changes will be lost after Arduino IDE update! platform.txt Another important file is platform.txt. This file defines the command patterns (recipes) that tell Arduino exactly how to compile, link, and package a sketch for a specific platform. It defines: the commands used for compiling and linking, how archives and output files are created, the flags and options passed to the compiler, and the commands used to calculate the size of the final program. Basically, this is the most important file telling us how Arduino builds a program. Unlike traditional C/C++ projects, there is no Makefile in the Arduino build system ‚Äî instead, platform.txt provides all the recipes that define each step of the build process. Behind the scenes, the Arduino IDE uses arduino-cli to build sketches according to these recipes. The arduino-cli tool expands and executes the command patterns defined in platform.txt. For example, the recipe for compiling a C source file is as follows: ## Compile c files recipe.c.o.pattern=\"{compiler.path}{compiler.c.cmd}\" {compiler.c.flags} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_ARCH_RENESAS -DARDUINO_FSP -D_XOPEN_SOURCE=700 {compiler.fsp.cflags} {compiler.tinyusb.cflags} {compiler.c.extra_flags} {build.extra_flags} {tinyusb.includes} \"-I{build.core.path}/api/deprecated\" \"-I{build.core.path}/api/deprecated-avr-comp\" {includes} \"-iprefix{runtime.platform.path}\" \"@{compiler.fsp.includes}\" -o \"{object_file}\" \"{source_file}\" Toolchains Inside the Arduino15‚Äôs tools directory, you will also find the cross-compilation toolchains used to build sketches for different microcontroller architectures. In my setup, two toolchains are installed: .arduino15/packages/arduino/tools/arm-none-eabi-gcc, for ARM based boards, like Arduino UNO R4 WiFi, .arduino15/packages/arduino/tools/avr-gcc, for AVR/Atmega based boards. The main components of toolchain are compiler, asembler and linker. Everything that is required to build for a specific architecture. Why we need cross compilation toolchains? When building application for embedded devices, the compilation happens on the hos","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Build directory When you compile a sketch, the build artifacts (i.e. intermediate object files) are not stored in the same directory as your source code. It would make a mess inside your sketch folder, or even made conflicts when building the same sketch for different boards. That‚Äôs why build files are always stored in separate build directory. In case of Arduino IDE, the build directory is a per-sketch cache, created in a hidden folder. You can find the path to this build directory in the build log. My sketch was built here: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/`. If you open this folder, you‚Äôll see the build artifacts, including: object files (.o), preprocessed sources (.cpp), final binaries (.bin, .hex, .elf). Exporting Compiled Binary If you want to have the compiled binaries in your sketch folder, click Sketch ‚Üí Export Compiled Binary option from Arduino IDE menu. This will build your sketch and place a copy of the .hex, .bin, .elf and .map inside the sketch sources folder so it‚Äôs easy to find later. Do you want to move Arduino15 folder? In some cases, you may want to move the Arduino15 folder ‚Äî for example, to free up space on your primary drive. To do this: Copy the Arduino15 directory to your desired location. Open the file ~/.arduinoIDE/arduino-cli.yaml and update the directories:data path, for example: board_manager: additional_urls: [] directories: data: /home/kate/new-location-arduino15 Restart the Arduino IDE. It will now use the new Arduino15 location. Verify the build output to ensure everything is working correctly. Once you‚Äôve confirmed everything works correctly, you can safely delete the old folder. We already discussed board identification and the Arduino specific directories. Let‚Äôs move to actual build process. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"General embedded software build process At a high level, the Arduino build process is essentially a C++ build process adapted for embedded targets, and with some Arduino specific features. The general C/C++ build pipeline is presented below: General C/C++ build process Now, let‚Äôs go through each stage and see how Arduino adapts the standard C/C++ build process for embedded targets. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Preprocessing The first phase of every C/C++ program build is preprocessing. In general, preprocessor expands macros like #include, #define, and conditional compilation (#if, #ifdef, etc.). The output is an expanded source file. In Arduino, some additional steps are added around preprocessing stage. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Concatenating .ino files If the sketch contains of multiple .ino files, they are first concatenated into a single .cpp file. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Detecting libraries used Arduino uses a special build recipe (recipe.preproc.macros [1]) to detect which libraries are required by your sketch. During this step, the preprocessor scans the sketch for #include directives that reference library header files. If a matching header is found, the corresponding library is automatically marked as required and included in the build process ‚Äî in other words, that library will be compiled and then linked in next stages of build process. Detecting libraries used... /home/kate/.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/arm-none-eabi-g++ (...) -E \\ /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /dev/null The -E flag tells GCC to perform only the preprocessing step ‚Äî it expands all macros and headers, then stops before compiling or assembling anything. For a simple sketch like Blink, this stage isn‚Äôt very exciting ‚Äî it doesn‚Äôt detect in any additional libraries. That‚Äôs why the build output doesn‚Äôt show anything under Detecting libraries used‚Ä¶. But if you open other example sketches, such as those from WiFiS3 or EEPROM, you‚Äôll see how more complex projects trigger detection of multiple libraries. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Generating function prototypes The next stage in the build process is automatic function prototype generation. In C or C++, each function must be either defined or declared before it‚Äôs called. In Arduino, you don‚Äôt need to worry about that ‚Äî you can write functions in any order, without adding their prototypes. How does it work? Arduino generates these prototypes for you! Here‚Äôs what the build log shows: Generating function prototypes... arm-none-eabi-g++ (...) -E /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /tmp/1121713208/sketch_merged.cpp ctags (...) /tmp/1121713208/sketch_merged.cpp Again, the compiler is invoked with the -E flag, meaning only the preprocessor runs. This is what happens now: Preprocessing The MyBlink.ino.cpp (file concatenated of all .ino files) is input for the preprocessor: #includes are expanded and macros replaces. The expanded file is stored as /tmp/1121713208/sketch_merged.cpp. Scanning functions Tool ctags is running over expanded sketch_merged.cpp, to extract function symbols. Generating prototypes Based on the ctags result, Arduino environment inserts forward declarations for you. This way, you don‚Äôt need to worry about undeclared functions, functions order, etc. Store prototypes into .ino.cpp The resulting version is stored into MyBlink.ino.cpp. This is what the compiler will actually use later on. Your simple sketch (MyBlink.ino): void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } gets transformed into (MyBlink.ino.cpp): #include \u003cArduino.h\u003e #line 1 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup(); #line 32 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void loop(); #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } The key differences can be summarized as follows: #include \u003cArduino.h\u003e is added, function prototypes are added, #line macros are added ‚Äî they keep compiler error messages pointing to the right lines in your .ino file. Without them, errors would show up with the line numbers of the generated .cpp, which would be super confusing. This is the first preprocessing step, unique to Arduino. Now, sketch/MyBlink.ino.cpp is not yet fully expanded ‚Äî you can see this file inside your sketch‚Äôs hidden cache. After that, the standard C/C++ preprocessing takes place when compiler is invoked again in next step ‚Äî all #include directives are replaced with the contents of the included files, all #defines macros are expanded, and the result is one fully expanded source file ready for compilation. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compilation Compilation is where your code is translated into the low-level machine instructions that the microcontroller can actually execute. In other words, your human-readable program becomes something the hardware understands. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Sketch compilation During this step, the compiler finalizes preprocessing (the standard C/C++ preprocessing that was not yet performed), checks your code for syntax errors and converts it into the object code that can be linked with libraries later. Compiling sketch... arm-none-eabi-g++ (...) -c sketch/MyBlink.ino.cpp -o sketch/MyBlink.ino.cpp.o Compiler is invoked with -c flag, which means compile and assemble (don‚Äôt link yet). It also performs the standard preprocessing phase as part of this step. Input: MyBlink.ino.cpp ‚Äî the auto-generated sketch with prototypes, includes, and line directives. Output: MyBlink.ino.cpp.o ‚Äî machine-code object file, ready to be linked later. I shortened the compilation command, so it‚Äôs not in the snippet above, but in IDE we can observe a lots of compilation flags that were used. Some highlights: -Os ‚Üí optimize for size [1]. -g3 ‚Üí include debug info at max level [1]. -fno-rtti, -fno-exceptions ‚Üí strip C++ runtime features to save space [1], . -nostdlib ‚Üí don‚Äôt link against standard system libraries [1]. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 ‚Üí target an ARM Cortex-M4 with hardware floating point. -I and @.../includes.txt ‚Üí add search paths for Arduino core and variant headers. Many -D... ‚Üí defines for board, CPU frequency, Arduino version, etc. Note Most advanced IDEs let you change compiler settings like optimization level, debug info, or extra flags right from a project menu. Arduino IDE is so simple that it doesn‚Äôt offer this option: you don‚Äôt get a button or menu for that. If you want to change some settings, you‚Äôve got several ways: Edit build recipes: you can change files like platform.txt or boards.local.txt to change or add your own compilation flags, modify arduino-cli.yaml from ArduinoIDE folder, use Arduino CLI directly: the command-line tool gives you more flexibility and can build your sketch with whatever options you like. At this point, your sketch has been turned into machine code, stored in MyBlink.ino.cpp.o. This file contains your setup() and loop() code, ready to be linked with the Arduino core and libraries in the next step. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling libraries All libraries, that were marked as required, are compiled now. Compiling libraries... For the Blink sketch this step is empty. In the previous phase (Detecting libraries used) no additional libraries were found. Blink only relies on core Arduino functions such as pinMode, digitalWrite, and delay, which are part of the board core, not separate libraries. In more advanced sketches the output looks different. For example, in WiFiS3/ConnectWithWPA the WiFiS3 library is detected and its source files are compiled here. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling core All needed core objects are compiled. Compiling core... Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/pin_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/main.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/common_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/variant.cpp.o Using precompiled core: /home/kate/.cache/arduino/cores/arduino_renesas_uno_unor4wifi_4e1bf6711f2b98688d9a4a386931d6dc/core.a The core is the foundation of every Arduino program (we discussed it in Arduino core chapter). Instead of recompiling the same core files every time you build, the Arduino IDE uses precompiled objects from a cache to speed up the compilation. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Linking Once all the individual files are compiled, the Arduino build system needs to link them into a single program. I shortened the link command to present only the most important stuff: arm-none-eabi-g++ \\ -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16 \\ -o MyBlink.ino.elf \\ MyBlink.ino.cpp.o common_data.c.o main.c.o pin_data.c.o variant.cpp.o \\ libfsp.a core.a \\ -lstdc++ -lsupc++ -lm -lc -lgcc -lnosys After this step, the final binary will be MyBlink.ino.elf. Take a look at libraries that are linked into the build: libfsp.a ‚Üí the Renesas Flexible Software Package, providing hardware drivers and low-level functions for peripherals. core.a ‚Üí the Arduino core for this board. Libraries above are board support libraries. These are part of the Arduino board package (for the Uno R4 in this case). They are not optional user libraries, so they don‚Äôt appear in the detection phase. Toolchain standard libraries: -lstdc++ ‚Üí the C++ standard library, -lsupc++ ‚Üí low-level C++ runtime support, -lm ‚Üí the math library, -lc ‚Üí the standard C library, -lgcc ‚Üí helper routines from GCC itself, -lnosys ‚Üí stubs for system calls. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Finalizing build Build is ready! Arduino will perform two more steps before finishing the process. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Creating binary and hex files After the ELF file (MyBlink.ino.elf) is created, the build system uses objcopy to generate hex and bin formats: arm-none-eabi-objcopy -O binary -j .text -j .data MyBlink.ino.elf MyBlink.ino.bin arm-none-eabi-objcopy -O ihex -j .text -j .data MyBlink.ino.elf MyBlink.ino.hex Both formats contain the same program, just encoded differently for different flashing tools. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Measuring the program size Finally, the build system reports memory usage with arm-none-eabi-size: arm-none-eabi-size -A MyBlink.ino.elf ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Cleaning the build Unfortunately, Arduino IDE does not offer the Clean build or Force rebuild option ([1], [2], [3]). The workaround for it is to manually delete the cached build directories we mentioned earlier. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Summary While it‚Äôs often called the Arduino language, .ino files are actually written in C++. They simply receive some automatic handling from the Arduino build system, and the main() function is predefined and hidden within a library. Arduino build process follows standard C/C++ build steps, but adds some additions: automatically detects libraries that need to be linked, includes main header, generates function prototypes if they are not included. Arduino doesn‚Äôt use Make or any other common build system. Instead, it uses arduino-cli which constructs build commands based on recipies from platform.txt and boards.txt. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:10:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"More reading Build Sketch Process from docs.arduino.cc Find sketches, libraries, board cores and other files on your computer from support.arduino.cc De-Mystifying Libraries - How Arduino IDE Finds and Uses Your Files - OhioIoT ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:11:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino builds your code","uri":"/arduino-ide-build-process/"},{"categories":null,"content":"Learning resources about embedded systems, ARM microcontrollers, C and C++ programming","date":"2025-10-25","objectID":"/resources/","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"This is my personal collection of resources that I find useful or interesting for learning embedded systems. It‚Äôs still small, but I‚Äôll keep expanding it over time. üòÑ üóÇÔ∏è Legend üìù ‚Äî Technical references / Tutorials üìñ ‚Äî Books üí¨ ‚Äî Essays / Opinions üß© ‚Äî Exercises ","date":"2025-10-25","objectID":"/resources/:0:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"Programming basics üìñ Competitive Programmer‚Äôs Handbook, Antti Laaksonen ","date":"2025-10-25","objectID":"/resources/:1:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"Programming Languages Exercising üß© Exercism ","date":"2025-10-25","objectID":"/resources/:2:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"Assembly and reverse engineering ","date":"2025-10-25","objectID":"/resources/:3:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"ARM üìù ARM Reverse Engineering Notes ","date":"2025-10-25","objectID":"/resources/:3:1","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"x86 üìù FFmpeg School of Assembly Language ","date":"2025-10-25","objectID":"/resources/:3:2","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"Compilers üìù A Compiler Writing Journey ","date":"2025-10-25","objectID":"/resources/:4:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"Arduino üí¨ Don‚Äôt use Arduino for professional work ","date":"2025-10-25","objectID":"/resources/:5:0","tags":null,"title":"Embedded Systems Learning Resources","uri":"/resources/"},{"categories":null,"content":"About me","date":"2025-09-14","objectID":"/about/","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Hi, I‚Äôm Kate! Welcome to my space where I share my thoughts and notes on embedded systems programming ‚Äî and everything loosely related to it. ","date":"2025-09-14","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Newsletter Found something interesting here? If you want to get updates on new posts, tutorials, and other embedded-related topics, just leave your email below: ","date":"2025-09-14","objectID":"/about/:1:0","tags":null,"title":"About me","uri":"/about/"}]