[{"categories":["Arduino Internals"],"content":"Build and upload Arduino sketches using Arduino CLI. Installing Arduino CLI, setting up boards, uploading sketches, and customizing commands","date":"2025-10-01","objectID":"/arduino-cli-compilation/","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"In the previous post we took a closer look at how the Arduino IDE builds sketches. A lot happens behind the scenes — from the classic C/C++ build steps (preprocessing, compiling, assembling, and linking) to a few Arduino-specific additions. Now, let’s take things a step further and build the same project without the Arduino IDE — this time using the Arduino CLI (Arduino Command Line Interface). Compiling Arduino sketch via Arduino CLI It’s worth to start with mentioning that, starting with Arduino IDE 2.0, the Arduino IDE uses the Arduino CLI for the build process. This means that when you build a sketch using the CLI directly, it follows exactly the same steps as the IDE does. So, what’s the point of using the CLI directly? There are several advantages: Advanced configuration options Some build or configuration options aren’t exposed in the IDE. It’s possible to configure them via configuration files for the IDE, but it makes this process more complicated and harder to maintain (the configuration file can be per-sketch or global). With the CLI, you can fully control compiler flags, board settings, library versions from command line. Automation and integration The CLI makes it easy to compile, verify, and upload sketches automatically. It can run on systems without a graphical interface, such as Docker containers. We will try to use it for creating simple CI/CD pipeline later. Reproducibility Makes sure that your colleague compiles with exactly the same setup as you. It solves the “it works on my machine” problem. IDE independence Use your favourite IDE for code development! You don’t have to use Arduino IDE if you don’t want! I am sure it was enough to convince you to give it a try, so let’s start! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Installing Arduino CLI In September 2024, Arduino released a major update to Arduino CLI. As of October 2025, the latest version is Arduino CLI 1.3.1, which I’ll be using here. Please refer to official installation guide to install Arduino CLI. Note On Linux, I installed the Arduino CLI in just a few seconds with just one command: curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Setup your board core After Arduino CLI is installed, you need to install needed boards definitions [1]. First, let’s update the board index: arduino-cli core update-index Then you need to install the core relevant for your board. Right now, we don’t know what is the core id that we need. So let’s peek what we can choose: ~/Arduino/MyBlink$ arduino-cli core search Downloading index: package_index.tar.bz2 downloaded ID Version Name arduino:avr 1.8.6 Arduino AVR Boards arduino:esp32 2.0.18-arduino.5 Arduino ESP32 Boards arduino:megaavr 1.8.8 Arduino megaAVR Boards arduino:nrf52 1.0.2 Arduino nRF52 Boards arduino:renesas_uno 1.5.1 Arduino UNO R4 Boards arduino:sam 1.6.12 Arduino SAM Boards (32-bits ARM Cortex-M3) ... Ok, so it’s clear now, that for Arduino UNO R4 WiFi that I have I need to use arduino:renesas_uno ID. So let’s install needed boards definitions: arduino-cli core install arduino:renesas_uno The preparations are done! ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Creating a new sketch You can create new sketch with $ arduino-cli sketch new MyFirstSketch Sketch created in: /XXX/MyFirstSketch But I want to reuse MyBlink sketch, that I was already working on, as in previous post. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Compile a sketch To compile a sketch, use arduino-cli compile command followed by: --fqbn \u003cid\u003e - your board id, \u003csketch root dir\u003e - the path to root directory of the sketch to compile. So to compile MyBlink that was previously compiled with the IDE, I will use: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi /home/kate/Arduino/MyBlink Again, like we already saw in IDE, the default output is very concise. arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi /home/kate/Arduino/MyBlink Sketch uses 51880 bytes (19%) of program storage space. Maximum is 262144 bytes. Global variables use 6740 bytes (20%) of dynamic memory, leaving 26028 bytes for local variables. Maximum is 32768 bytes. We can enable verbose output here too. arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Uploading a sketch Before we jump to upload command, we must now to which port is the board connected. How can we check it? Good news — no need to observe ls /dev/tty* with board plugged and unplugged. There is a command for it too: arduino-cli board list Port Protocol Type Board Name FQBN Core /dev/ttyACM0 serial Serial Port (USB) Arduino UNO R4 WiFi arduino:renesas_uno:unor4wifi arduino:renesas_uno Knowing the port, board ID and sketch directory, the upload command looks like this: arduino-cli upload -p /dev/ttyACM0 --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink So it was basically all needed to replace the usage of Arduino IDE Verify/Compile and Upload actions. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Customizing command The compile command can be extended with additional stuff, like extra compiler flags: arduino-cli compile --fqbn arduino:renesas_uno:unor4wifi --verbose /home/kate/Arduino/MyBlink --build-property compiler.c.extra_flags=\"-Wall -O2\" Full documentation of Arduino CLI commands is here: https://arduino.github.io/arduino-cli/1.3/commands ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Permanent CLI settings If you want to set permanent settings to your CLI, create a config file if you haven’t: arduino-cli config init Config file written to: /home/kate/.arduino15/arduino-cli.yaml Take a look, if you’ve just created it, it should be empty now: arduino-cli config dump board_manager: additional_urls: [] Settings added globally to this file will affect all builds done with Arduino CLI. You can also set some options per-board. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Summary Using the Arduino CLI gives you full control over the build process, from compiling to uploading sketches, without relying on the Arduino IDE. It’s perfect for automation, reproducibility, and integrating Arduino projects into advanced workflows or CI/CD pipelines. In the next post, we’ll explore how to automate builds and uploads. ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:8:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"More reading https://docs.arduino.cc/arduino-cli/ https://arduino.github.io/arduino-cli/1.3/getting-started/ https://evan.widloski.com/notes/arduino_cli.html https://dumblebots.com/blog/arduino-cli-getting-started https://www.pcbway.com/blog/Activities/Arduino_cli__compile__upload_and_manage_libraries__cores__and_boards.html ","date":"2025-10-01","objectID":"/arduino-cli-compilation/:9:0","tags":["Arduino Internals"],"title":"Arduino Internals: building sketches with Arduino CLI","uri":"/arduino-cli-compilation/"},{"categories":["Arduino Internals"],"content":"Step by step guide to how the Arduino IDE builds the code — preprocessing, compiling, and linking explained simply","date":"2025-09-13","objectID":"/arduino-ide-build-process/","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"As an embedded developer, you probably can’t help wondering what actually happens when Arduino IDE builds the sketch. What’s being compiled, where the files go, and how the toolchain turns the code into instructions able to run on the board? You hit the spot! We’re about to take a closer look at the Arduino build process. While building an Arduino sketch in the IDE seems as simple as clicking one button, under the hood it performs several important steps — some common to nearly every embedded development environment, and others unique to Arduino. Understanding this process is a great way to move beyond the beginner stage and start thinking like an embedded developer. Understanding Arduino IDE build process Assumed knowledge I assume you already know how to compile and flash an Arduino board with the Arduino IDE, but haven’t yet dived into the internals of the compilation and flashing process. My setup Arduino UNO R4 WiFi board Arduino IDE 2.3.6 Linux Mint If you’re using a different board, IDE version, or operating system — don’t worry! You can still follow along. Some details may just look a little different on your setup. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:0:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"What you will learn? After reading this article, you will: understand the standard build flow in embedded software development, learn about the additional steps performed during the Arduino build process, know where to find the build files and caches. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:1:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Let’s get started! Let’s build a sketch together and go step through the build process. We’ll pretend we know nothing and analyze the build output to infer what the Arduino IDE actually did. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Build an example sketch Open the Arduino IDE and select the correct board from Select Board menu. In my case it’s Arduino UNO R4 WiFi. Load the Blink example and save the sketch in your sketchbook. Then, to trigger the build, click Verify/Compile and observe the Output window. It looks that the sketch has been built successfully and is ready to upload to the board. The message contains just two lines because I haven’t changed the Arduino IDE’s default settings yet — by default, most of the build output is hidden. Arduino IDE - default build output ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Enable verbose output To understand the build process better we need to enable the verbose output in IDE. To do so, go to File-\u003e Preferences and check Show verbose output setting for both compiling and upload. When you compile again, the output will be complete. Let’s break it down to atoms! Arduino IDE - verbose build output ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:2:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Board and package identification In embedded software development, the compilation process is always target-dependent. Each hardware architecture — such as ARM or AVR — requires its own dedicated toolchain. That’s why the first lines in Output are identifying the board. Before the build process starts, Arduino environment checks which board you are using, based on what you have selected in Select Board menu. Thanks to this, the compiled code will match the board’s architecture, hardware, pin mapping etc. This board identity is called FQBN (Fully Qualified Board Name) and looks as follows: FQBN: arduino:renesas_uno:unor4wifi FQBN is unique for each board. It consists of three segments: Vendor: arduino (it’s official Arduino package) Architecture: renesas_uno (Renesas-based boards family) Board: unor4wifi (exact model: Arduino Uno R4 WiFi). If you choose wrong board, the code may compile but fail at runtime, or compilation may fail. Tip Error Compilation error: Missing FQBN (Fully Qualified Board Name) means you have not selected any board from menu. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:3:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino specific directories It’s also useful to know where the compilation artifacts end up and where the packages used for building a specific target are stored. This isn’t immediately obvious, since these files are placed in several hidden directories. However, their locations can be found in the build log. Let’s take a quick look at these directories. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino15 directory Arduino15 contains user preferences, downloaded board packages (cores, toolchains, board definitions) and libraries that Arduino automatically installs. The exact location depends on your operating system. Files related to the target board can be found in the path displayed in the build log under the FQBN, for example: Using board 'unor4wifi' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 Using core 'arduino' from platform in folder: /home/kate/.arduino15/packages/arduino/hardware/renesas_uno/1.4.1 There are several interesting files in this directory. One of them is boards.txt file, which lists all boards supported by that platform. Each board has its own section with key-value pairs that define how to compile, upload, and debug for that target. Here’s the entry for the Arduino UNO R4 WiFi: ############################################################## unor4wifi.name=Arduino UNO R4 WiFi unor4wifi.build.core=arduino unor4wifi.build.crossprefix=arm-none-eabi- unor4wifi.build.compiler_path={runtime.tools.arm-none-eabi-gcc-7-2017q4.path}/bin/ unor4wifi.build.variant=UNOWIFIR4 unor4wifi.build.mcu=cortex-m4 unor4wifi.build.architecture=cortex-m4 unor4wifi.build.fpu=-mfpu=fpv4-sp-d16 unor4wifi.build.float-abi=-mfloat-abi=hard unor4wifi.upload.tool=bossac ... Thanks to those settings, once you select your board from the Select Board menu, the correct toolchain, compiler flags (such as MCU type and clock speed) and upload tool are selected automatically. Toolchain Arduino15 also contains the toolchain:.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/. Besides the compiler itself, toolchain contains other useful tools like objdump. We will use it later! Do you want to move Arduino15 folder? In some cases, you may want to move the Arduino15 folder — for example, to free up space on your primary drive. To do this: Copy the Arduino15 directory to your desired location. Open the file ~/.arduinoIDE/arduino-cli.yaml and update the directories:data path, for example: board_manager: additional_urls: [] directories: data: /home/kate/new-location-arduino15 Restart the Arduino IDE. It will now use the new Arduino15 location. Verify the build output to ensure everything is working correctly. Once you’ve confirmed everything works correctly, you can safely delete the old folder. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Arduino core The Arduino core directory provides the hardware-specific implementation of core Arduino functions. It is located in the cores subdirectory of your board package, for example: .arduino15/packages/arduino/hardware/renesas_uno/1.4.1/cores/ Each board family, or platform, has its own core, tailored to the hardware and peripherals. The Arduino core contains, among other files: main.cpp — defines the startup code that runs before your setup() function and repeatedly calls your loop() function, Arduino.h header — the main header file included by all sketches, implementation of interrupts, UART communication, timing functions like delay and other low-level routines. Open the main.cpp and browse the logic that Arduino is adding around the code you implemented in the sketch. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Build directory When you compile a sketch, the build artifacts (i.e. intermediate object files) are not stored in the same directory as your source code. It would make a mess inside your sketch folder, or even made conflicts when building the same sketch for different boards. That’s why build files are always stored in separate build directory. In case of Arduino IDE, the build directory is a per-sketch cache, created in a hidden folder. You can find the path to this build directory in the build log. My sketch was built here: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/`. If you open this folder, you’ll see the build artifacts, including: object files (.o), preprocessed sources (.cpp), final binaries (.bin, .hex, .elf). Exporting Compiled Binary If you want to have the compiled binaries in your sketch folder, click Sketch → Export Compiled Binary option from Arduino IDE menu. This will build your sketch and place a copy of the .hex, .bin, .elf and .map inside the sketch sources folder so it’s easy to find later. We already discussed board identification and the Arduino specific directories. Let’s move to actual build process. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:4:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"General embedded software build process At a high level, the Arduino build process is essentially a C++ build process adapted for embedded targets, and with some Arduino specific features. The general C/C++ build pipeline is presented below: General C/C++ build process ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:5:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Preprocessing The first phase of every C/C++ program build is preprocessing. In general, preprocessor expands macros like #include, #define, and conditional compilation (#if, #ifdef, etc.). The output is a single expanded source file. In Arduino, some additional steps are added around preprocessing stage. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Concatenating .ino files If the sketch contains of multiple .ino files, they are first concatenated into a single .cpp file. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Detecting libraries used Arduino uses a special build recipe (recipe.preproc.macros [1]) to detect which libraries are required by your sketch. During this step, the preprocessor scans the sketch for #includes that reference library header files. If a matching header is found, the corresponding library is automatically marked as needed and included in the build process. Detecting libraries used... /home/kate/.arduino15/packages/arduino/tools/arm-none-eabi-gcc/7-2017q4/bin/arm-none-eabi-g++ (...) -E \\ /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /dev/null As we see in build output, the compiler is invoked with the -E flag, which tells it to stop after the preprocessing stage and not produce any compiled output. For a simple sketch like Blink, this stage isn’t very exciting: it doesn’t detect in any additional libraries. That’s why the build output doesn’t show anything under Detecting libraries used…. Open other example sketches, such as those from WiFiS3 or EEPROM, and you’ll see how more complex projects trigger detection of multiple libraries. Why does Arduino detect libraries automatically? The Arduino IDE compiles only the libraries that your sketch actually needs — no manual setup required. In most other development environments, this step is up to the developer: you have to configure which libraries or dependencies should be included in the build. Arduino takes care of this automatically, keeping things simple and beginner-friendly. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Generating function prototypes The next stage in the build process is automatic function prototype generation. In C or C++, each function must be either defined or declared before it’s called. In Arduino, you don’t need to worry about that — you can write functions in any order, without adding their prototypes. How does it work? Arduino generates these prototypes for you! Here’s what the build log shows: Generating function prototypes... arm-none-eabi-g++ (...) -E /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/sketch/MyBlink.ino.cpp -o /tmp/1121713208/sketch_merged.cpp ctags (...) /tmp/1121713208/sketch_merged.cpp Again, the compiler is invoked with the -E flag, meaning only the preprocessor runs. This is what happens now: Preprocessing The MyBlink.ino.cpp (file concatenated of all .ino files) is input for the preprocessor: #includes are expanded and macros replaces. The expanded file is stored as /tmp/1121713208/sketch_merged.cpp. Scanning functions Tool ctags is running over expanded sketch_merged.cpp, to extract function symbols. Generating prototypes Based on the ctags result, Arduino environment inserts forward declarations for you. This way, you don’t need to worry about undeclared functions, functions order, etc. Store prototypes into .ino.cpp The resulting version is stored into MyBlink.ino.cpp. This is what the compiler will actually use later on. Your simple sketch (MyBlink.ino): void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } gets transformed into (MyBlink.ino.cpp): #include \u003cArduino.h\u003e #line 1 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup(); #line 32 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void loop(); #line 26 \"/home/kate/Arduino/MyBlink/MyBlink.ino\" void setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(6000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } To summarize differences: #include \u003cArduino.h\u003e is added, #line macros are added — they keep compiler error messages pointing to the right lines in your .ino file. Without them, errors would show up with the line numbers of the generated .cpp, which would be super confusing. function prototypes are added. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:6:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compilation Here’s where your code finally turns into machine instructions that the microcontroller can execute. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Sketch compilation During this step, the compiler checks your code for syntax errors and converts it into the object code that can be linked with libraries later. Compiling sketch... arm-none-eabi-g++ (...) -c sketch/MyBlink.ino.cpp -o sketch/MyBlink.ino.cpp.o Compiler is invoked with -c flag, which means compile only (and don’t link yet). Input: MyBlink.ino.cpp - the auto-generated sketch with prototypes, includes, and line directives. Output: MyBlink.ino.cpp.o - machine-code object file, ready to be linked later. I shortened the compilation command, so it’s not in the snippet above, but in IDE we can observe a lots of compilation flags that were used. Some highlights: -Os → optimize for size. -g3 → include debug info at max level. -fno-rtti, -fno-exceptions → strip C++ runtime features to save space. -nostdlib → don’t link against standard system libraries [1]. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 → target an ARM Cortex-M4 with hardware floating point. -I and @.../includes.txt → add search paths for Arduino core and variant headers. Many -D... → defines for board, CPU frequency, Arduino version, etc. Note Most advanced IDEs let you change compiler settings like optimization level, debug info, or extra flags right from a project menu. Arduino IDE is so simple that it doesn’t offer this option: you don’t get a button or menu for that. If you want to change some settings, you’ve got several ways: Edit build recipes: you can change files like platform.txt or boards.local.txt to change or add your own compilation flags, modify arduino-cli.yaml from ArduinoIDE folder, use Arduino CLI directly: the command-line tool gives you more flexibility and can build your sketch with whatever options you like. At this point, your sketch has been turned into machine code, stored in MyBlink.ino.cpp.o. This file contains your setup() and loop() code, ready to be linked with the Arduino core and libraries in the next step. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling libraries Compiling libraries... For the Blink sketch this step is empty. In the previous phase (Detecting libraries used) no additional libraries were found. Blink only relies on core Arduino functions such as pinMode, digitalWrite, and delay, which are part of the board core, not separate libraries. In more advanced sketches the output looks different. For example, in WiFiS3/ConnectWithWPA the WiFiS3 library is detected and its source files are compiled here. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Compiling core Compiling core... Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/pin_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/main.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/tmp_gen_c_files/common_data.c.o Using previously compiled file: /home/kate/.cache/arduino/sketches/D7CC1D7CA645BCFE67207C07A05B3A2A/core/variant.cpp.o Using precompiled core: /home/kate/.cache/arduino/cores/arduino_renesas_uno_unor4wifi_4e1bf6711f2b98688d9a4a386931d6dc/core.a The core is the foundation of every Arduino program. We disussed in in Arduino core chapter. Instead of recompiling the same core files every time you build, the Arduino IDE uses precompiled objects from a cache. It speeds up the compilation. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:7:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Linking everything together Once all the individual files are compiled, the Arduino build system needs to link them into a single program. I shortened the link command to present only the most important stuff: arm-none-eabi-g++ \\ -mcpu=cortex-m4 -mfloat-abi=hard -mfpu=fpv4-sp-d16 \\ -o MyBlink.ino.elf \\ MyBlink.ino.cpp.o common_data.c.o main.c.o pin_data.c.o variant.cpp.o \\ libfsp.a core.a \\ -lstdc++ -lsupc++ -lm -lc -lgcc -lnosys After this step, the final binary will be MyBlink.ino.elf. Please note which libraries are linked into the build: libfsp.a → the Renesas Flexible Software Package, providing hardware drivers and low-level functions for peripherals. core.a → the Arduino core for this board. Libraries above are board support libraries. These are part of the Arduino board package (for the Uno R4 in this case). They are not optional user libraries, so they don’t appear in the detection phase. Toolchain standard libraries: -lstdc++ → the C++ standard library, -lsupc++ → low-level C++ runtime support, -lm → the math library, -lc → the standard C library, -lgcc → helper routines from GCC itself, -lnosys → stubs for system calls. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:8:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Finalizing build ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Creating binary and hex files After the ELF file (MyBlink.ino.elf) is created, the build system uses objcopy to generate hex and bin formats: arm-none-eabi-objcopy -O binary -j .text -j .data MyBlink.ino.elf MyBlink.ino.bin arm-none-eabi-objcopy -O ihex -j .text -j .data MyBlink.ino.elf MyBlink.ino.hex Both formats contain the same program, just encoded differently for different flashing tools. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:1","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Measuring the program size Finally, the build system reports memory usage with arm-none-eabi-size: arm-none-eabi-size -A MyBlink.ino.elf ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:2","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"Cleaning the build Unfortunately, Arduino IDE does not offer the Clean build or Force rebuild option ([1], [2], [3]). The workaround for it is to manually delete the cached build directories we mentioned earlier. ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:9:3","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":["Arduino Internals"],"content":"More reading Build Sketch Process from docs.arduino.cc Find sketches, libraries, board cores and other files on your computer from support.arduino.cc ARM Reverse Engineering Notes: Compilation Open issues in arduino-cli related to build process De-Mystifying Libraries - How Arduino IDE Finds and Uses Your Files - OhioIoT ","date":"2025-09-13","objectID":"/arduino-ide-build-process/:10:0","tags":["Arduino Internals"],"title":"Arduino Internals: how Arduino IDE builds your code","uri":"/arduino-ide-build-process/"},{"categories":null,"content":"About embeddedk8","date":"2025-09-14","objectID":"/about/","tags":null,"title":"About embeddedk8","uri":"/about/"}]